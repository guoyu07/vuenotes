\part{ECMAScript}

\chapter{Overview}


2015年6月发布的ECMAScript 6.0（简称ES6）是JavaScript语言的下一代标准，其目标是使得JavaScript语言成为可以用来编写复杂的大型应用程序的企业级开发语言。

\section{ECMAScript1.0}


1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。

该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。

因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。

\section{ECMAScript2.0}


ECMAScript 1.0是1997年发布的，接下来的两年，连续发布了ECMAScript 2.0（1998年6月）和ECMAScript 3.0（1999年12月）。


\section{ECMAScript3.0}

ECMAScript 3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学3.0版的语法。

\section{ECMAScript4.0}

2000年，ECMAScript 4.0开始酝酿。这个版本最后没有通过，但是它的大部分内容被ES6继承了。因此，ES6制定的起点其实是2000年。


为什么ES4没有通过呢？因为这个版本太激进了，对ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。

2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。

2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。

\section{ECMAScript5.0}


2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39委员会的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第六版发布以后，就指ES7。TC39的判断是，ES5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。

\section{ECMAScript5.1}


2011年，ECMAScript 5.1版发布后，就开始制定6.0版了。因此，”ES6”这个词的原意，就是指JavaScript语言的下一个版本。

但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布6.0版，过一段时间再发6.1版，然后是6.2版、6.3版等等。

但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。

标准委员会最终决定，标准在每年的6月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的6月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。

\section{ECMAScript6}


ES6的第一个版本，就这样在2015年6月发布了，正式名称就是《ECMAScript 2015标准》（简称ES2015）。2016年6月，小幅修订的《ECMAScript 2016标准》（简称ES2016）如期发布，这个版本可以看作是ES6.1版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017年6月将发布ES2017标准。

\begin{compactitem}
\item ES6-ES 2015
\item ES6.1-ES 2016
\end{compactitem}



因此，ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。“ES6”一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。



\subsection{History}

ES6从开始制定到最后发布，整整用了15年。

前面提到，ECMAScript 1.0是1997年发布的，接下来的两年，连续发布了ECMAScript 2.0（1998年6月）和ECMAScript 3.0（1999年12月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学3.0版的语法。

2000年，ECMAScript 4.0开始酝酿。这个版本最后没有通过，但是它的大部分内容被ES6继承了。因此，ES6制定的起点其实是2000年。

为什么ES4没有通过呢？因为这个版本太激进了，对ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。

2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。

2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。

2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39委员会的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第六版发布以后，就指ES7。TC39的判断是，ES5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。

2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。

2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。

2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。

2015年6月，ECMAScript 6正式通过，成为国际标准。从2000年算起，这时已经过去了15年。


\subsection{Strict}


ES6 的模块自动采用严格模式，不管有没有在模块头部加上\texttt{"use strict"}。


严格模式主要有如下限制：

\begin{compactitem}
\item 变量必须声明后再使用
\item 函数的参数不能有同名属性，否则报错
\item 不能使用with语句
\item 不能对只读属性赋值，否则报错
\item 不能使用前缀0表示八进制数，否则报错
\item 不能删除不可删除的属性，否则报错
\item 不能删除变量\texttt{delete prop}，会报错，只能删除属性\texttt{delete global[prop]}
\item eval不会在它的外层作用域引入变量
\item eval和arguments不能被重新赋值
\item arguments不会自动反映函数参数的变化
\item 不能使用arguments.callee
\item 不能使用arguments.caller
\item 禁止this指向全局对象
\item 不能使用fn.caller和fn.arguments获取函数调用的堆栈
\item 增加了保留字（比如protected、static和interface）
\end{compactitem}

虽然严格模式是 ES5 引入的，不属于 ES6，但是上面这些限制，ES6模块都必须遵守。

其中，尤其需要注意this的限制。

\begin{compactitem}
\item ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。
\end{compactitem}




\subsection{Variable}


ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令之外还有两种声明变量的方法：import命令和class命令，所以ES6一共有6种声明变量的方法。



\subsection{Inheritance}


模块之间也可以继承。


假设有一个circleplus模块，继承了circle模块。

\begin{lstlisting}[language=JavaScript]
// circleplus.js

export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}
\end{lstlisting}


上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。

这时，也可以将circle的属性或方法，改名后再输出。


\begin{lstlisting}[language=JavaScript]
// circleplus.js

export { area as circleArea } from 'circle';
\end{lstlisting}



上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。

加载上面模块的写法如下。




\begin{lstlisting}[language=JavaScript]
// main.js

import * as math from 'circleplus';
import exp from 'circleplus';
console.log(exp(math.e));
\end{lstlisting}

上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\chapter{Module}

Python的import、Ruby的require和CSS的@import等都确保了模块功能的实现，JavaScript一直缺少模块（Module）的概念，导致当项目规模增大时，JavaScritpt代码变得难以复用且极难维护。




在ES6发布之前，JavaScript社区就制定了CommonJS（node模块化加载）和AMD（RequireJS）等规范来实现模块加载。

\begin{compactitem}
\item CommonJS用于服务器环境；
\item AMD用于浏览器环境。
\end{compactitem}

\section{Overview}


历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，现在ES6在语言标准层面上使用export和import实现了模块化功能，至此JavaScript开始正式提供模块支持。

ES6的模块功能支持完全可以取代 CommonJS 和 AMD 规范，并成为浏览器和服务器通用的模块解决方案。

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。

\subsection{Object}


相比而言，CommonJS 模块和AMD模块都只能在运行时确定上述这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。


\begin{lstlisting}[language=JavaScript]
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于ES6
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readFile = _fs.readfile;
\end{lstlisting}

上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（\_fs），然后再从这个对象上面读取3个方法，这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

\subsection{Method}


ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。




\begin{lstlisting}[language=JavaScript]
// ES6模块
import { stat, exists, readFile } from 'fs';
\end{lstlisting}

上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。


由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。


除了静态加载带来的各种好处，ES6 模块还有以下好处：

\begin{compactitem}
\item 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
\item 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
\item 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
\end{compactitem}


模块功能主要由两个命令构成：export和import，而且二者支持as别名。

\begin{compactitem}
\item export命令用于规定模块的对外接口；
\item import命令用于输入其他模块提供的功能。
\end{compactitem}



\begin{lstlisting}[language=JavaScript]
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
}
\end{lstlisting}

\begin{compactitem}
\item export使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。
\end{compactitem}

\begin{lstlisting}[language=JavaScript]

\end{lstlisting}

\subsection{Scope}


\begin{compactitem}
\item export和import命令可以出现在模块的任何位置，只要处于模块顶层就可以；
\item export和import命令处于块级作用域内的时候，就会报错。
\end{compactitem}


如果export和import处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。

\begin{lstlisting}[language=JavaScript]
function foo() {
  export default 'bar' // SyntaxError
}
foo()
\end{lstlisting}

上面代码中，export语句放在函数之中，结果报错。



\section{Alias}


\subsection{as}


通常情况下，export输出的变量除了是本来的名字之外，export也支持使用as语法进行别名export，这样就可以把一个接口通过多个名字对外暴露。

\begin{lstlisting}[language=JavaScript]
// ---- lib.js ----
const sqrt = Math.sqrt;
// 使用两个别名对外暴露sqrt
export { sqrt as sq1, sqrt as sq2 };
\end{lstlisting}

和CommonJS规范完全不同的是，ES6模块规范规定，如果b模块从a模块导入一个原始值后，在a模块中修改这个原始值，那么b模块中的值也会与a模块中最新的值保持同步，即export暴露的接口与其在模块内部对应的值是动态绑定的关系，通过接口可以获取模块内部实时的值。例如，下面的示例代码输出变量foo，值为bar，500毫秒之后变成baz。


\begin{lstlisting}[language=JavaScript]
export var foo = 'bar';
setTimeout(() => foo = 'baz', 500);
\end{lstlisting}

\begin{compactitem}
\item CommonJS 模块输出的是值的缓存，不存在动态更新
\item ES6模块输出的是和模块内部动态绑定的值，存在动态更新。
\end{compactitem}


需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。


\begin{lstlisting}[language=JavaScript]
// 报错
export 1;

// 报错
var m = 1;
export m;
\end{lstlisting}

上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。

\begin{compactenum}
\item 写法1

\begin{lstlisting}[language=JavaScript]
export var m = 1;
\end{lstlisting}

\item 写法2

\begin{lstlisting}[language=JavaScript]
var m = 1;
export {m};
\end{lstlisting}

\item 写法3

\begin{lstlisting}[language=JavaScript]
var n = 1;
export {n as m};
\end{lstlisting}
\end{compactenum}

上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。

同样的，function和class的输出，也必须遵守这样的写法。

\begin{lstlisting}[language=JavaScript]
// 报错
function f() {}
export f;

// 正确
export function f() {};

// 正确
function f() {}
export {f};
\end{lstlisting}


import也支持使用as语法对导入的变量进行重命名。


\begin{lstlisting}[language=JavaScript]
// ---- lib.js ----
export var myVar1  'var1';
// ---- main.js ----
import {myVar1 as myCustomVar1 } from './lib';
console.log(myCustomVar1);
\end{lstlisting}

import默认会执行加载的模块，因此ES6支持空import，例如：


\begin{lstlisting}[language=JavaScript]
// 只加载并执行模块，不引用任何接口
import 'lib';
\end{lstlisting}

import还可以通过整体加载模块来提供命名空间的支持，例如：



\begin{lstlisting}[language=JavaScript]
// ---- lib.js ----
export var myVar1 = 'var1';
export let myVar2 = 'var2';
export const MY_CONST = 'my_const';

export function myFunc() {
   return 'myFunc';
}

export function* myGeneratorFunc() {
   // ...
}

export class MyClass {
   // ...
}

// ---- main.js ----
import * as lib from './lib';
console.log(lib.myVar1);
console.log(lib.myVar2);
new lib.MyClass();
\end{lstlisting}




\subsection{default}

默认情况下，使用模块接口时必须要知道该模块导出了哪些接口，对于只暴露一个接口的模块实际上就没有必要限定暴露的接口名字，因此ES6支持使用\texttt{export default}语法让接口调用者自定义要导入的接口名字。



\begin{example}
导入单接口模块时可以自定义接口名字
\begin{lstlisting}[language=JavaScript]
// ---- myFunc.js ----
export default function() { }

// ---- main.js ----
import myFunc from 'myFunc';
myFunc();
\end{lstlisting}
\end{example}

从本质上来说，export default就是输出一个名为default的变量或方法，然后系统允许对其进行重命名，因此export default的意义是可以让开发者更直观的引入模块。




\begin{lstlisting}[language=JavaScript]
// lib.js
function add(x,y) {
    return x * y;
}

export { add as default };
// 等同于
export default add; 
//执行add
> add(2,3)
6

// ---- main.js ----
import { default as myAdd } from 'lib';
// 等同于
import myAdd from 'lib';
// 执行myAdd
> myAdd(2,3);
6
\end{lstlisting}




使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载，现在ES6的export default命令可以为模块指定默认输出，这样当其他模块加载该模块时，import命令就可以为该匿名函数指定任意名字。



\begin{lstlisting}[language=JavaScript]
// export-default.js
export default function () {
  console.log('foo');
}

// import-default.js
import customName from './export-default';
customName(); // 'foo'
\end{lstlisting}


export default命令用在非匿名函数前，也是可以的。

\begin{lstlisting}[language=JavaScript]
// export-default.js
export default function foo() {
  console.log('foo');
}

// 或者写成

function foo() {
  console.log('foo');
}

export default foo;
\end{lstlisting}

上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。


下面比较一下默认输出和正常输出。

\begin{lstlisting}[language=JavaScript]
// 第一组
export default function crc32() { // 输出
  // ...
}

import crc32 from 'crc32'; // 输入

// 第二组
export function crc32() { // 输出
  // ...
};

import {crc32} from 'crc32'; // 输入
\end{lstlisting}

上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。

export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。

本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。

\begin{lstlisting}[language=JavaScript]
// modules.js
function add(x, y) {
  return x * y;
}
export {add as default};
// 等同于
// export default add;

// app.js
import { default as xxx } from 'modules';
// 等同于
// import xxx from 'modules';
\end{lstlisting}


export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。


\begin{lstlisting}[language=JavaScript]
// 正确
export var a = 1;

// 正确
var a = 1;
export default a;

// 错误
export default var a = 1;
\end{lstlisting}


上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。

同样地，因为export default本质是将该命令后面的值，赋给default变量以后再默认，所以直接将一个值写在export default之后。


\begin{lstlisting}[language=JavaScript]
// 正确
export default 42;

// 报错
export 42;
\end{lstlisting}

上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default。

有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。

\begin{lstlisting}[language=JavaScript]
import _ from 'lodash';
\end{lstlisting}



同样地，jQuery可以以下面的方式来引入：




\begin{lstlisting}[language=JavaScript]
import $ from 'jquery';
\end{lstlisting}

如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。


\begin{lstlisting}[language=JavaScript]
import _, { each } from 'lodash';
\end{lstlisting}

对应上面代码的export语句如下。


\begin{lstlisting}[language=JavaScript]
export default function (obj) {
  // ···
}

export function each(obj, iterator, context) {
  // ···
}

export { each as forEach };
\end{lstlisting}

上面代码的最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。

export default也可以用来输出类。

\begin{lstlisting}[language=JavaScript]
// MyClass.js
export default class { ... }

// main.js
import MyClass from 'MyClass';
let o = new MyClass();
\end{lstlisting}

Vue.js采用export和import来进行模块化开发，代码通过export暴露接口并import引用其他文件中的功能。例如，下面是Vue.js的入口文件/src/core/index.js的内容：

\begin{lstlisting}[language=JavaScript]
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
import { isServerRendering } from 'core/util/env'

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
   get: isServerRendering
})

Vue.version = '__VERSION__'

export default Vue
\end{lstlisting}

下面的代码使用正常的方式向外界暴露了三个函数方法：

\begin{lstlisting}[language=JavaScript]
export function orderBy(...) {},
export function filterBy(...) {},
export function limitBy(...) {}
\end{lstlisting}

在引入上述三个函数时的语法如下：



\begin{lstlisting}[language=JavaScript]
import { orderBy, filterBy, limitBy } from './array-filters'
\end{lstlisting}


\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}

\section{export}

ES6支持一个文件就是一个模块。






\subsection{Variable}



一个模块内部的所有变量，对于外界来说是无法获取的，除非使用关键词export对外暴露接口（或变量）。


\begin{example}
export向外界暴露变量
\begin{lstlisting}[language=JavaScript]
//-----profile.js----
/*
暴露三个变量给外界
*/
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1989;

// 或者
export { firstName, lastName, year };

// ----main.js----
import {firstName, lastName, year} from './profile';

function setName(element) {
   element.textContent = firstName + ' ' + lastName;
}
\end{lstlisting}
\end{example}


\subsection{Function}


export对外暴露的各个接口通过名字来进行区分。例如，下面的示例中的lib.js模块通过sqrt、square、diag向外界暴露了三个接口：



\begin{example}
export向外界暴露接口
\begin{lstlisting}[language=JavaScript]
//-----lib.js----
/*
暴露三个接口给外界
*/
export const sqrt = Math.sqrt;
export function square(x) {
   return x * x;
}
export function diag(x,y) {
   return sqrt(square(x) + square(y));
}
\end{lstlisting}
\end{example}

export支持使用大括号的方式指定要向外界暴露的接口，例如：






\begin{lstlisting}[language=JavaScript]
//-----lib.js----
/*
以大括号形式暴露三个接口给外界
*/
const sqrt = Math.sqrt;
function square(x) {
   return x * x;
}
function diag(x,y) {
   return sqrt(square(x) + square(y));
}

export { sqrt, square, diag };
\end{lstlisting}

注意，应该优先考虑使用大括号的写法来指定要export给外界的变量或接口。

\subsection{Class}

export支持输出变量、函数或类（class）。




\section{import}

在使用export从模块对外界暴露接口后，其他的JavaScript文件就可以通过import命令加载这个模块（文件）。例如，在main.js模块中就可以通过import导入lib.js暴露的接口：


\begin{example}
import导入其他ES6文件暴露的接口
\begin{lstlisting}[language=JavaScript]
// ---- main.js ----
/* 
通过import语法从lib模块中导入所需要的接口
*/
import { square, diag } from './lib';
console.log(square(11)); // 121
console.log(diag(4,3)); // 5
\end{lstlisting}
\end{example}

除了指定加载某个输出值，import还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。


下面是一个circle.js文件，它输出两个方法area和circumference。

\begin{lstlisting}[language=JavaScript]
// circle.js

export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}
\end{lstlisting}


现在，加载这个模块。

\begin{lstlisting}[language=JavaScript]
// main.js

import { area, circumference } from './circle';

console.log('圆面积：' + area(4));
console.log('圆周长：' + circumference(14));
\end{lstlisting}

上面写法是逐一指定要加载的方法，整体加载的写法如下。





\begin{lstlisting}[language=JavaScript]
import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));
\end{lstlisting}

注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。


\begin{lstlisting}[language=JavaScript]
import * as circle from './circle';

// 下面两行都是不允许的
circle.foo = 'hello';
circle.area = function () {};
\end{lstlisting}




\subsection{Variable}


import导入外部接口时，大括号中的接口（或变量）必须已经通过export关键字导出，名字也必须相同。


\begin{example}
import导入其他ES6文件暴露的变量
\begin{lstlisting}[language=JavaScript]
// ----main.js----
import {firstName, lastName, year} from './profile';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}
\end{lstlisting}
\end{example}


import命令支持使用as关键字，将输入的变量重命名。

\begin{lstlisting}[language=JavaScript]
import { lastName as surname } from './profile';
\end{lstlisting}


\subsection{Function}



import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。

\begin{lstlisting}[language=JavaScript]
import {myMethod} from 'util';
\end{lstlisting}

上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。

注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。

\begin{lstlisting}[language=JavaScript]
foo();

import { foo } from 'my_module';
\end{lstlisting}


上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。



由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。


\begin{lstlisting}[language=JavaScript]
// 报错
import { 'f' + 'oo' } from 'my_module';

// 报错
let module = 'my_module';
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}
\end{lstlisting}


上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。

最后，import语句会执行所加载的模块，因此可以有下面的写法。

\begin{lstlisting}[language=JavaScript]
import 'lodash';
\end{lstlisting}


上面代码仅仅执行lodash模块，但是不输入任何值。

如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。



\begin{lstlisting}[language=JavaScript]
import 'lodash';
import 'lodash';
\end{lstlisting}

上面代码加载了两次lodash，但是只会执行一次。




\begin{lstlisting}[language=JavaScript]
import { foo } from 'my_module';
import { bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
\end{lstlisting}

上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my\_module实例。也就是说，import语句是 Singleton 模式。


如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。


\begin{lstlisting}[language=JavaScript]
export { foo, bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
export { foo, bar };
\end{lstlisting}

上面代码中，export和import语句可以结合在一起，写成一行。

模块的接口改名和整体输出，也可以采用这种写法。

\begin{lstlisting}[language=JavaScript]
// 接口改名
export { foo as myFoo } from 'my_module';

// 整体输出
export * from 'my_module';
\end{lstlisting}


默认接口的写法如下。

\begin{lstlisting}[language=JavaScript]
export { default } from 'foo';
\end{lstlisting}

具名接口改为默认接口的写法如下。


\begin{lstlisting}[language=JavaScript]
export { es6 as default } from './someModule';

// 等同于
import { es6 } from './someModule';
export default es6;
\end{lstlisting}

同样地，默认接口也可以改名为具名接口。


\begin{lstlisting}[language=JavaScript]
export { default as es6 } from './someModule';
\end{lstlisting}

下面三种import语句，没有对应的复合写法。




\begin{lstlisting}[language=JavaScript]
import * as someIdentifier from "someModule";
import someIdentifier from "someModule";
import someIdentifier, { namedIdentifier } from "someModule";
\end{lstlisting}


现在已经提案提出补上这三种复合写法来做到形式的对称：

\begin{lstlisting}[language=JavaScript]
export * as someIdentifier from "someModule";
export someIdentifier from "someModule";
export someIdentifier, { namedIdentifier } from "someModule";
\end{lstlisting}


\section{import()}



import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）。所以，下面的代码会报错。


\begin{lstlisting}[language=JavaScript]
// 报错
if (x === 2) {
  import MyModual from './myModual';
}
\end{lstlisting}


上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。

这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。从语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。

\begin{lstlisting}[language=JavaScript]
const path = './' + fileName;
const myModual = require(path);
\end{lstlisting}


上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import语句做不到这一点。因此，有一个提案，建议引入import()函数，完成动态加载。


\begin{lstlisting}[language=JavaScript]
import(specifier)
\end{lstlisting}

上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。

import()返回一个 Promise 对象。下面是一个例子。

\begin{lstlisting}[language=JavaScript]
const main = document.querySelector('main');

import(`./section-modules/${someVariable}.js`)
  .then(module => {
    module.loadPageInto(main);
  })
  .catch(err => {
    main.textContent = err.message;
  });
\end{lstlisting}


import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，也会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。

import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。


下面是import()的一些适用场合。

\subsection{按需加载}


import()可以在需要的时候，再加载某个模块。


\begin{lstlisting}[language=JavaScript]
button.addEventListener('click', event => {
  import('./dialogBox.js')
  .then(dialogBox => {
    dialogBox.open();
  })
  .catch(error => {
    /* Error handling */
  })
});
\end{lstlisting}

上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。

\subsection{条件加载}

import()可以放在if代码块，根据不同的情况，加载不同的模块。



\begin{lstlisting}[language=JavaScript]
if (condition) {
  import('moduleA').then(...);
} else {
  import('moduleB').then(...);
}
\end{lstlisting}

上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。

\subsection{动态的模块路径}

import()允许模块路径动态生成。

\begin{lstlisting}[language=JavaScript]
import(f())
.then(...);
\end{lstlisting}

上面代码中，根据函数f的返回结果，加载不同的模块。

import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。



\begin{lstlisting}[language=JavaScript]
import('./myModule.js')
.then(({export1, export2}) => {
  // ...·
});
\end{lstlisting}

上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。

如果模块有default输出接口，可以用参数直接获得。


\begin{lstlisting}[language=JavaScript]
import('./myModule.js')
.then(myModule => {
  console.log(myModule.default);
});
\end{lstlisting}

上面的代码也可以使用具名输入的形式。





\begin{lstlisting}[language=JavaScript]
import('./myModule.js')
.then(({default: theDefault}) => {
  console.log(theDefault);
});
\end{lstlisting}


如果想同时加载多个模块，可以采用下面的写法。

\begin{lstlisting}[language=JavaScript]
Promise.all([
  import('./module1.js'),
  import('./module2.js'),
  import('./module3.js'),
])
.then(([module1, module2, module3]) => {
   ···
});
\end{lstlisting}


import()也可以用在 async 函数之中。



\begin{lstlisting}[language=JavaScript]
async function main() {
  const myModule = await import('./myModule.js');
  const {export1, export2} = await import('./myModule.js');
  const [module1, module2, module3] =
    await Promise.all([
      import('./module1.js'),
      import('./module2.js'),
      import('./module3.js'),
    ]);
}
main();
\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\chapter{Scope}

在ES5以及之前的版本中都不支持块级作用域，只有全局作用域和函数作用域，从ES6开始支持全局作用域、函数作用域和块级作用域。



代码中的任何一对花括号中的语句集合都属于一个块，如果其中定义的所有变量在代码块外部都是不可见的，那么就称之为块级作用域。

如果只有全局作用域和函数作用域，那么内层变量可能会覆盖外层变量，用于计数的循环变量可能泄露为全局变量等。

第一种场景，内层变量可能会覆盖外层变量。



\begin{lstlisting}[language=JavaScript]
> var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = "hello world";
  }
}

f(); // undefined
\end{lstlisting}

上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

第二种场景，用来计数的循环变量泄露为全局变量。

\begin{lstlisting}[language=JavaScript]
> var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
\end{lstlisting}

上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

\section{let}


在ECMAScript不支持块级作用域之前，往往需要通过闭包等方式来模拟块级作用域，let实际上为ES6提供了块级作用域的直接支持。

\begin{lstlisting}[language=JavaScript]
> function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
\end{lstlisting}

上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。


let和var的作用都是声明变量，虽然let的用法和var类似，但是var和let是不同的。

\begin{compactitem}
\item var声明的变量可以在全局作用域或函数作用域内有效；
\item let声明的变量只在let所在的代码块内有效。
\end{compactitem}


\begin{lstlisting}[language=JavaScript]
> 
{
  let a = 'hello';  
  var b = 'world';
}
> a;
Uncaught ReferenceError: a is not defined
    at <anonymous>:1:1
> b;
"abc"
> try{ a } catch (e) { console.log(e.message); }
a is not defined
> try{ a } catch (e) { console.log(e.name); }
ReferenceError
> try{ a } catch (e) { console.log(e.toString()); }
ReferenceError: a is not defined
> try{ a } catch (e) { console.log(e.constructor); }
function ReferenceError() { [native code] }
\end{lstlisting}

上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值，因此let声明的变量只在它所在的代码块有效。

\begin{compactitem}
\item 在用let声明的a的代码块之外调用a会报错；
\item 在用var声明的b的代码块之外调用b则返回正确值。
\end{compactitem}

let声明的变量只在其所在代码块内有效，var声明的变量可以在全局内、函数内或块内都有效。

let适合用于声明局部变量（例如for循环的计数器变量i），代码示例如下：


\begin{lstlisting}[language=JavaScript]
> for (let i = 0; i < 5; i++){
  console.log(i);
}
< 
0
1
2
3
4
> console.log(i);
Uncaught ReferenceError: i is not defined
    at <anonymous>:1:51
\end{lstlisting}

上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。

下面的代码如果使用var，最后输出的是10。

\begin{lstlisting}[language=JavaScript]
> var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
\end{lstlisting}

上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。

如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。

\begin{lstlisting}[language=JavaScript]
> var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
\end{lstlisting}

上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。

可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。

\begin{lstlisting}[language=JavaScript]
> for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
\end{lstlisting}

上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。

let不允许在相同作用域内重复声明同一个变量，否则在相同作用域内，使用let重复声明同一个变量会报错，ES6不能在函数内部重新声明参数。


\begin{lstlisting}[language=JavaScript]
> function() {
  let a = 'hello';
  let a = 'world'; // 报错
}

> function() {
  let c = 10;
  var c = 1; // 报错
}
< 
Uncaught SyntaxError: Identifier 'a' has already been declared
>
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
\end{lstlisting}

\begin{compactitem}
\item var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。
\item let不存在变量提升，因此变量需要在声明后才可以使用，否则会报错。
\end{compactitem}


\begin{lstlisting}[language=JavaScript]
> console.log(foo); console.log(bar); let foo = 'hello'; var bar = 'world';
Uncaught SyntaxError: Identifier 'foo' has already been declared
    at <anonymous>:1:1
\end{lstlisting}

let存在“暂时性死区”（temporal dead zone，简称TDZ），也就是说在代码块内，使用let声明变量之前，该变量不可用的。

let命令改变了语法行为来纠正var命令的“变量提升”现象，let所声明的变量一定要在声明后使用，否则报错。

\begin{lstlisting}[language=JavaScript]
> if(true){
  // var 的情况
  console.log(foo); // 输出undefined
  var foo = 2;
  
  // let 的情况
  console.log(bar); // 报错ReferenceError
  let bar = 2;
  
  // TDZ开始
  tmp = 'hello'; // ReferenceError
  console.log(tmp); // ReferenceError
  
  let tmp; // TDZ结束
  console.log(tmp); // undefined
  
  tmp = 123;
  console.log(tmp); // 123
}
\end{lstlisting}

\begin{compactitem}
\item 变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。
\item 变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。
\end{compactitem}

只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，这就是TDZ的实质。

\begin{lstlisting}[language=JavaScript]
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
\end{lstlisting}

上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

\begin{lstlisting}[language=JavaScript]
> typeof x; // ReferenceError
let x;
\end{lstlisting}


上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。

作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。

\begin{lstlisting}[language=JavaScript]
> typeof undeclared_variable // "undefined"
\end{lstlisting}

上面代码中，undeclared\_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

有些“死区”比较隐蔽，不太容易发现。

\begin{lstlisting}[language=JavaScript]
> function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
\end{lstlisting}

上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。

\begin{lstlisting}[language=JavaScript]
> function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
\end{lstlisting}


下面的代码也会报错，与var的行为不同。

\begin{lstlisting}[language=JavaScript]
> // 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
\end{lstlisting}

上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。

ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

暂时性死区的本质就是只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

总而言之，let相比var更严谨，更不易发生错误，同时支持块级作用域。例如，Vue.js使用let来保存全局配置信息等：






\begin{lstlisting}[language=JavaScript]
let delimiters = ['{{','}}']
let unsafeDelimiters = ['{{{','}}}']
\end{lstlisting}

下面的runBatcherQueue函数中的for循环变量就是使用let来声明的：






\begin{lstlisting}[language=JavaScript]
function runBatcherQueue(queue) {
  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for(let i = 0; i < queue.lenght; i++) {
     // ...
  }
  queue.length = 0
}
\end{lstlisting}


\subsection{Nested Scope}

ES6允许块级作用域的任意嵌套。


\begin{lstlisting}[language=JavaScript]
{{{{{let insane = 'Hello World'}}}}};
\end{lstlisting}

上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。



\begin{lstlisting}[language=JavaScript]
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
\end{lstlisting}

内层作用域可以定义外层作用域的同名变量。

\begin{lstlisting}[language=JavaScript]
{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
\end{lstlisting}

块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。


\begin{lstlisting}[language=JavaScript]
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
\end{lstlisting}


\subsection{Function Declaration}


函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

\begin{lstlisting}[language=JavaScript]
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
\end{lstlisting}

虽然上面两种函数声明，根据 ES5 的规定都是非法的，但是，浏览器没有遵守这个规定。

为了兼容以前的旧代码，浏览器还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。

\begin{lstlisting}[language=JavaScript]
// ES5严格模式
'use strict';
if (true) {
  function f() {}
}
// 报错
\end{lstlisting}

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。



\begin{lstlisting}[language=JavaScript]
// ES6
if (true) {
  function f() {} // 不报错
}
\end{lstlisting}

ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。


\begin{lstlisting}[language=JavaScript]
function f() { console.log('I am outside!'); }
(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
\end{lstlisting}


上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下：


\begin{lstlisting}[language=JavaScript]
// ES5 版本
function f() { console.log('I am outside!'); }
(function () {
  function f() { console.log('I am inside!'); }
  if (false) {
  }
  f();
}());
\end{lstlisting}



ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下：



\begin{lstlisting}[language=JavaScript]
// ES6 版本
function f() { console.log('I am outside!'); }
(function () {
  f();
}());
\end{lstlisting}

在 ES6 浏览器中运行上面的代码时是会报错的，原因是ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6规定浏览器的实现可以不遵守上面的规定，有自己的行为方式，例如：

\begin{compactitem}
\item 允许在块级作用域内声明函数。
\item 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
\item 同时，函数声明还会提升到所在的块级作用域的头部。
\end{compactitem}

注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。


根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。




\begin{lstlisting}[language=JavaScript]
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
\end{lstlisting}

上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。




\begin{lstlisting}[language=JavaScript]
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
\end{lstlisting}

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。


\begin{lstlisting}[language=JavaScript]
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
\end{lstlisting}


另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。



\begin{lstlisting}[language=JavaScript]
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
\end{lstlisting}

\subsection{Block Statement}

本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。



\begin{lstlisting}[language=JavaScript]
{
  let t = f();
  t = t * t + 1;
}
\end{lstlisting}

上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。

现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。

\begin{lstlisting}[language=JavaScript]
let x = do {
  let t = f();
  t * t + 1;
};
\end{lstlisting}

上面代码中，变量x会得到整个块级作用域的返回值。



\section{const}


\subsection{Constant}



const用于声明一个常量，一旦声明就会进入只读模式，常量的值就不能再被更改。


\begin{lstlisting}[language=JavaScript]
> const PI = 3.141;
> PI // 3.141
> PI = 3; 
Uncaught TypeError: Assignment to constant variable.
    at <anonymous>:1:4
> PI
3.141 //重新赋值无效,PI值不变
\end{lstlisting}

上面代码表明改变常量的值会报错。

虽然const声明的常量只在当前代码块有效，但是如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。



\begin{lstlisting}[language=JavaScript]
// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import {A, B} from './constants';
console.log(A); // 1
console.log(B); // 3
\end{lstlisting}

如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。

\begin{lstlisting}[language=JavaScript]
// constants/db.js
export const db = {
  url: 'http://my.couchdbserver.local:5984',
  admin_username: 'admin',
  admin_password: 'admin password'
};

// constants/user.js
export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];
\end{lstlisting}

然后，将这些文件输出的常量，合并在index.js里面。




\begin{lstlisting}[language=JavaScript]
// constants/index.js
export {db} from './db';
export {users} from './users';
\end{lstlisting}

使用的时候，直接加载index.js就可以了。


\begin{lstlisting}[language=JavaScript]
// script.js
import {db, users} from './constants';
\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\subsection{Variable}


在严格模式下，对已使用const声明的变量重新赋新值会报错。

const声明后不得再更改的特性意味着在声明const变量时就必须初始化，不能仅声明而不进行初始化，或者留到以后进行赋值。





\begin{lstlisting}[language=JavaScript]
> const PI;
Uncaught SyntaxError: Missing initializer in const declaration
\end{lstlisting}

在严格模式下，使用const声明变量不赋值会报错。

const的作用域和let相同，只在声明所在的块级作用域内有效，const和let都不允许重复声明，不存在变量提升，而且const和let都有TDZ。

\begin{compactitem}
\item const的作用域和let相同；
\item const和let声明的变量只在声明所在的块级作用域内有效；
\item const和let都不允许重复声明；
\item const和let都不存在变量提升；
\item const和let都有TDZ。
\end{compactitem}

const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。


\begin{lstlisting}[language=JavaScript]
if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
\end{lstlisting}


上面代码在常量MAX声明之前就调用，结果报错。

const声明的常量，也与let一样不可重复声明。

\begin{lstlisting}[language=JavaScript]
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
\end{lstlisting}

const在声明复合类型的变量时，只能保证变量名指向的地址不变，并不保证该地址的数据不变。

复合类型的变量名指向数据地址而不指向数据，因此使用const声明一个对象，只是保证变量名指向的地址不变，并不保证该地址的数据不变，也就不能保证对象不可更改，所以将一个对象声明为常量必须非常小心。








\begin{lstlisting}[language=JavaScript]
> const obj = {};
> obj.age = 4;
> obj
Object {age: 4}
> obj = {};
Uncaught TypeError: Assignment to constant variable.
    at <anonymous>:1:5
\end{lstlisting}

上面代码中，常量obj储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把obj指向另一个地址，但是对象本身是可变的，所以依然可以为其添加新属性。


使用const声明一个对象后，对象内的属性仍然可以修改，但是不可修改对象所指向的地址。

下面是另一个例子。

\begin{lstlisting}[language=JavaScript]
> const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
\end{lstlisting}

上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a就会报错。



ES6提供了Object.freeze()、Object.seal()和Object.preventExtensions()等方法来标记一个对象为不可扩展的（non-extensible）。

\begin{lstlisting}[language=JavaScript]
> const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
\end{lstlisting}

上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

\begin{lstlisting}[language=JavaScript]
> var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, value) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
\end{lstlisting}

Vue.js中的常用变量都采用const来声明，例如Vue.js的transition的动画类型的声明如下：


\begin{lstlisting}[language=JavaScript]
const TYPE_TRANSITION = 'transition';
const TYPE_ANIMATION = 'animation';
\end{lstlisting}



Vue.js的正则检测的常量也是用const来声明，这样正则表达式一经声明就不可再更改。







\begin{lstlisting}[language=JavaScript]
const bindRE = /^:|^v-bind:/
const onRE = /^@|^v-on:/
const argRE = /:(.*)$/
const modifierRE = /\.[^\.]+/g
\end{lstlisting}



\chapter{Object}


\section{Toplevel Object}

顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。



\begin{lstlisting}[language=JavaScript]
window.a = 1;
a // 1

a = 2;
window.a // 2
\end{lstlisting}

上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。

顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。


ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。




\begin{lstlisting}[language=JavaScript]
var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
\end{lstlisting}

上面代码中，全局变量a和b分别解释如下：

\begin{compactitem}
\item 全局变量a由var命令声明，所以它是顶层对象的属性；
\item 全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。
\end{compactitem}


\section{Global Object}


ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的，例如：

\begin{compactitem}
\item 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
\item 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。
\item Node 里面，顶层对象是global，但其他环境都不支持。
\end{compactitem}

同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是还是有局限性。

\begin{compactitem}
\item 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。
\item 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
\item 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。
\end{compactitem}

综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。

\begin{lstlisting}[language=JavaScript]
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
\end{lstlisting}

现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。

垫片库system.global模拟了这个提案，可以在所有环境拿到global。

\begin{lstlisting}[language=JavaScript]
// CommonJS的写法
require('system.global/shim')();

// ES6模块的写法
import shim from 'system.global/shim'; shim();
\end{lstlisting}

上面代码可以保证各种环境里面，global对象都是存在的。



\begin{lstlisting}[language=JavaScript]
// CommonJS的写法
var global = require('system.global')();

// ES6模块的写法
import getGlobal from 'system.global';
const global = getGlobal();
\end{lstlisting}

上面代码将顶层对象放入变量global。

\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}

\section{Object.create}

创建一个拥有指定原型和若干指定属性的对象。

下面的示例使用Object.create()实现类式继承（这是一个单继承）：

\begin{lstlisting}[language=JavaScript]
// Shape - superclass
function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function(x,y) {
  this.x += x;
  this.y += y;
  console.info("Shape moved.");
};

// Rectange - subclass
function Rectangle() {
  Shape.call(this); // call super constructor
}

Rectangle.prototype = Object.create(Shape.prototype);

var rect = new Rectangle();

rect instanceof Rectangle; // true
rect instanceof Shape; // true

rect.move(1,1); // "Shape moved."
\end{lstlisting}


\subsection{Syntax}


\begin{lstlisting}[language=JavaScript]
Object.create(proto, [ propertiesObject ])
\end{lstlisting}


\subsection{Parameter}


\begin{lstlisting}[language=JavaScript]
Object.create(proto, [ propertiesObject ])
\end{lstlisting}


\begin{compactitem}
\item proto(必选)：一个作为新创建对象的原型的对象
\item propertiesObject(可选)：该参数对象是一个数组与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。
\end{compactitem}

注意，propertiesObject不能是undefined，而且只有该对象自身拥有的可枚举的属性才有效，也就是说，该对象的原型链上的属性是无效的。

\subsection{Exception}

使用Object.create()创建对象时，如果proto参数不是null或对象值，那么就抛出一个TypeError异常。



Vue.js的src/core/global-api/extend.js中使用Object.create的示例如下：




\begin{lstlisting}[language=JavaScript]
/* @flow */

import config from '../config'
import { warn, mergeOptions } from '../util/index'

export function initExtend (Vue: GlobalAPI) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0
  let cid = 1

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this
    const isFirstExtend = Super.cid === 0
    if (isFirstExtend && extendOptions._Ctor) {
      return extendOptions._Ctor
    }
    let name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characaters and the hyphen.'
        )
        name = null
      }
    }
    const Sub = function VueComponent (options) {
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super
    // allow further extension
    Sub.extend = Super.extend
    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }
    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    // cache constructor
    if (isFirstExtend) {
      extendOptions._Ctor = Sub
    }
    return Sub
  }
}
\end{lstlisting}


\section{Object.keys}

返回一个字符串数组，其元素来自于给定对象上可枚举的属性，这些属性的顺序和手动遍历该对象属性时的一致。



\begin{lstlisting}[language=JavaScript]
var arr = ["a","b","c"];
alert(Object.keys(arr)); // 0,1,2
//类数组对象
var obj = {0: "a", 1:"b", 2:"c"};
alert(Object.keys(obj)); // 0,1,2
// getFoo是一个不可枚举的属性
var my_obj = Object.create({},{getFoo: {value: function() { return this.foo }}});
my_obj.foo = 1;
alert(Object.keys(my_obj)); // 只弹出foo
\end{lstlisting}

\subsection{Syntax}


\begin{lstlisting}[language=JavaScript]
Object.keys(obj)
\end{lstlisting}


\subsection{Parameter}




\begin{lstlisting}[language=JavaScript]
Object.keys(obj)
\end{lstlisting}


\begin{compactitem}
\item obj(必选)：返回该对象的所有可枚举自身属性的属性名
\end{compactitem}







\begin{lstlisting}[language=JavaScript]
// Mix properties into target object
export function extend (to,from) {
  var keys = Object.keys(from)
  var i = keys.length
  while (i--) {
    to[keys[i]] = from[keys[i]]
  }
  return to
}
\end{lstlisting}

\section{Object.isExtensible}

判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。


\subsection{Syntax}


\begin{lstlisting}[language=JavaScript]
Object.isExtensible(obj)
\end{lstlisting}


\subsection{Parameter}


\begin{compactitem}
\item \texttt{obj \{Object\} }
\end{compactitem}

默认情况下，对象是可扩展的，即可以为其添加新的属性并且其\_\_proto\_\_属性可以被更改。

Object.preventExtensions、Object.seal或Object.freeze方法都可以标记一个对象为不可扩展的（non-extensible）。

\begin{compactitem}
\item 在ES5中，如果参数不是对象类型，Object.isExtensible()将抛出一个TypeError异常。
\item 在ES6中，非对象参数将被视为一个不可扩展的普通对象，因此会返回false。
\end{compactitem}



\begin{lstlisting}[language=JavaScript]
// 新对象默认是可扩展的
var empty = {};
Object.isExtensible(empty); // ===true

// 新对象可以变得不可扩展
Object.preventExtensions(empty);
Object.isExtensible(empty); // ===false

// 密封对象是不可扩展的
var sealed = Object.seal({});
Object.isExtensible(sealed); // === false

// 冻结对象也是不可扩展的
var frozen = Object.freeze({});
Object.isExtensible(frozen); // === false
\end{lstlisting}



\section{Object.getOwnPropertyNames}

返回一个由指定对象的所有自身属性的属性名（包括不可枚举的属性）组成的数组。

\begin{compactitem}
\item 数组中枚举属性的顺序与通过for...in loop（或Object.keys）迭代该对象属性时的一致。
\item 数组中的不可枚举属性的顺序未定义。
\end{compactitem}

\subsection{Syntax}



\begin{lstlisting}[language=JavaScript]
Object.getOwnPropertyNames(obj)
\end{lstlisting}


\subsection{Parameter}


\begin{compactitem}
\item \texttt{obj \{Object\}}
\end{compactitem}



\begin{lstlisting}[language=JavaScript]
var arr = ["a","b","c"];
console.log(Object.getOwnPropertyNames(arr).sort()); 
// ["0","1","2","length"]

// 类数组对象
var obj = {0: "a", 1:"b", 2:"c"};
console.log(Object.getOwnPropertyNames(obj).sort());
// ["0","1","2"]

// 使用Array.forEach输出属性名和属性值
Object.getOwnPropertyNames(obj).forEach(function(val,idx,array){\
  console.log(val + " -> " + obj[val]);
});
// 输出
// 0 -> a
// 1 -> b
// 2 -> c

// 不可枚举的属性
var my_obj = Object.create({}, {
  getFoo: {
     value: function() {return this.foo;},
     enumerable: false
  }
});
my_obj.foo = 1;
console.log(Object.getOwnPropertyNames(my_obj).sort()); 
// ["foo","getFoo"]
\end{lstlisting}


\section{Object.defineProperty}

直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象。

Object.defineProperty()方法在Vue.js中发挥着极为重要的作用——Vue.js实现数据和视图联动的核心原理就是Object.defineProperty()。



\begin{lstlisting}[language=JavaScript]
/**
 * Define a property
 */
export function def(obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}
\end{lstlisting}


\subsection{Syntax}



\begin{lstlisting}[language=JavaScript]
Object.defineProperty(obj,prop,descriptor)
\end{lstlisting}

\subsection{Parameter}

\begin{compactitem}
\item obj：需要定义属性的对象
\item prop：需要被定义或修改的属性名
\item descriptor：需要被定义或修改的属性的描述符
\end{compactitem}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\chapter{Node.js}

ECMAScript方言（JavaScript和JScript等）都扩展了ECMAScript语言，或者标准库和相关API（例如W3C定义的DOM），不过这也这意味着以一种方言实现的程序不兼容于另一种方言的实现，除非程序使用了方言中的公共子集所具有的特性和API。

各大浏览器的最新版本都实现了ES6的大部分特性，Node.js对ES6的支持度比浏览器更高。

Node.js是JavaScript语言的服务器运行环境，通过Node可以体验更多ES6的特性，建议使用版本管理工具nvm来安装Node，因为可以自由切换版本。

Babel等JavaScript预编译期（或转码器）可以将ES6代码转换为ES5代码，从而在现有环境中执行。

\section{NVM}


安装nvm需要打开命令行窗口，运行下面的命令：

\begin{lstlisting}[language=JavaScript]
$ curl -o- https://raw.githubusercontent.com/creationix/nvm/<version number>/install.sh | JavaScript
[sudo] password for localhost: 
=> Downloading nvm from git to '/home/localhost/.nvm'
=> Cloning into '/home/localhost/.nvm'...
remote: Counting objects: 6082, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 6082 (delta 2), reused 0 (delta 0), pack-reused 6072
Receiving objects: 100% (6082/6082), 1.74 MiB | 152.00 KiB/s, done.
Resolving deltas: 100% (3752/3752), done.
Checking connectivity... done.
* (detached from v0.33.0)
  master
=> Compressing and cleaning up git repository
Counting objects: 6082, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6044/6044), done.
Writing objects: 100% (6082/6082), done.
Total 6082 (delta 4017), reused 1882 (delta 0)

=> Appending nvm source string to /home/localhost/.JavaScriptrc
=> JavaScript_completion source string already in /home/localhost/.JavaScriptrc
=> You currently have modules installed globally with `npm`. These will no
=> longer be linked to the active version of Node when you install a new node
=> with `nvm`; and they may (depending on how you construct your `$PATH`)
=> override the binaries of modules installed with `nvm`:
=> If you wish to uninstall them at a later point (or re-install them under your
=> `nvm` Nodes), you can remove them from the system Node as follows:

     $ nvm use system
     $ npm uninstall -g a_module

=> Close and reopen your terminal to start using nvm or run the following to use it now:

export NVM_DIR="/home/localhost/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
\end{lstlisting}



上面命令的version number处，需要用版本号替换。

上述命令运行后，nvm会默认安装在用户主目录的.nvm子目录，然后激活nvm。



\begin{lstlisting}[language=JavaScript]
$ source ~/.nvm/nvm.sh
\end{lstlisting}

激活以后，安装Node的最新版。


\begin{lstlisting}[language=JavaScript]
$ nvm install node
\end{lstlisting}


安装完成后，切换到该版本。


\begin{lstlisting}[language=JavaScript]
$ nvm use node
\end{lstlisting}

使用下面的命令，可以查看Node所有已经实现的ES6特性。


\begin{lstlisting}[language=JavaScript]
$ node --v8-options | grep harmony
  --es_staging (enable test-worthy harmony features (for internal use only))
  --harmony (enable all completed harmony features)
  --harmony_shipping (enable all shipped harmony features)
  --harmony_array_prototype_values (enable "harmony Array.prototype.values" (in progress))
  --harmony_function_sent (enable "harmony function.sent" (in progress))
  --harmony_sharedarraybuffer (enable "harmony sharedarraybuffer" (in progress))
  --harmony_simd (enable "harmony simd" (in progress))
  --harmony_explicit_tailcalls (enable "harmony explicit tail calls" (in progress))
  --harmony_do_expressions (enable "harmony do-expressions" (in progress))
  --harmony_restrictive_generators (enable "harmony restrictions on generator declarations" (in progress))
  --harmony_regexp_named_captures (enable "harmony regexp named captures" (in progress))
  --harmony_regexp_property (enable "harmony unicode regexp property classes" (in progress))
  --harmony_for_in (enable "harmony for-in syntax" (in progress))
  --harmony_trailing_commas (enable "harmony trailing commas in function parameter lists" (in progress))
  --harmony_regexp_lookbehind (enable "harmony regexp lookbehind")
  --harmony_tailcalls (enable "harmony tail calls")
  --harmony_async_await (enable "harmony async-await")
  --harmony_string_padding (enable "harmony String-padding methods")
  --harmony_restrictive_declarations (enable "harmony limitations on sloppy mode function declarations")
  --harmony_object_values_entries (enable "harmony Object.values / Object.entries")
  --harmony_object_own_property_descriptors (enable "harmony Object.getOwnPropertyDescriptors()")
\end{lstlisting}

上面命令的输出结果，会因为版本的不同而有所不同。


ES-Checker模块可以用来检查各种运行环境（例如Node或浏览器）对ES6的支持情况。


\begin{lstlisting}[language=JavaScript]
$ sudo npm install -g es-checker
$ es-checker
ECMAScript 6 Feature Detection (v1.4.0)

Variables
  √ let and const
  √ TDZ error for too-early access of let or const declarations
  √ Redefinition of const declarations not allowed
  √ destructuring assignments/declarations for arrays and objects
  √ ... operator

Data Types
  √ For...of loop
  √ Map, Set, WeakMap, WeakSet
  √ Symbol
  √ Symbols cannot be implicitly coerced

Number
  √ Octal (e.g. 0o1 ) and binary (e.g. 0b10 ) literal forms
  √ Old octal literal invalid now (e.g. 01 )
  √ Static functions added to Math (e.g. Math.hypot(), Math.acosh(), Math.imul() )
  √ Static functions added to Number (Number.isNaN(), Number.isInteger() )

String
  √ Methods added to String.prototype (String.prototype.includes(), String.prototype.repeat() )
  √ Unicode code-point escape form in string literals (e.g. \u{20BB7} )
  √ Unicode code-point escape form in identifier names (e.g. var \u{20BB7} = 42; )
  √ Unicode code-point escape form in regular expressions (e.g. var regexp = /\u{20BB7}/u; )
  √ y flag for sticky regular expressions (e.g. /b/y )
  √ Template String Literals

Function
  √ arrow function
  √ default function parameter values
  √ destructuring for function parameters
  √ Inferences for function name property for anonymous functions
  × Tail-call optimization for function calls and recursion

Array
  × Methods added to Array.prototype ([].fill(), [].find(), [].findIndex(), [].entries(), [].keys(), [].values() )
  √ Static functions added to Array (Array.from(), Array.of() )
  √ TypedArrays like Uint8Array, ArrayBuffer, Int8Array(), Int32Array(), Float64Array()
  √ Some Array methods (e.g. Int8Array.prototype.slice(), Int8Array.prototype.join(), Int8Array.prototype.forEach() ) added to the TypedArray prototypes
  √ Some Array statics (e.g. Uint32Array.from(), Uint32Array.of() ) added to the TypedArray constructors

Object
  √ __proto__ in object literal definition sets [[Prototype]] link
  √ Static functions added to Object (Object.getOwnPropertySymbols(), Object.assign() )
  √ Object Literal Computed Property
  √ Object Literal Property Shorthands
  √ Proxies
  √ Reflect

Generator and Promise
  √ Generator function
  √ Promises

Class
  √ Class
  √ super allowed in object methods
  √ class ABC extends Array { .. }

Module
  × Module export command
  × Module import command


=========================================
Passes 38 feature Detections
Your runtime supports 90% of ECMAScript 6
=========================================
\end{lstlisting}


\section{Babel}


Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。


\begin{lstlisting}[language=JavaScript]
// 转码前
input.map(item => item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
\end{lstlisting}



上面的原始代码用了箭头函数(\texttt{=>})，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行了。



Babel也可以用于浏览器环境。但是，从Babel 6.0开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或不想使用构建工具，可以通过安装5.x版本的babel-core模块获取。



\begin{lstlisting}[language=JavaScript]
$ npm install babel-core@5
\end{lstlisting}

运行上面的命令以后，就可以在当前目录的node\_modules/babel-core/子目录里面，找到babel的浏览器版本browser.js（未精简）和browser.min.js（已精简）。

然后，将下面的代码插入网页。

\begin{lstlisting}[language=JavaScript]
<script src="node_modules/babel-core/browser.js"></script>
<script type="text/babel">
// Your ES6 code
</script>
\end{lstlisting}


上面代码中，browser.js是Babel提供的转换器脚本，可以在浏览器运行。用户的ES6脚本放在script标签之中，但是要注明\texttt{type="text/babel"}。

另一种方法是使用babel-standalone模块提供的浏览器版本，将其插入网页。


\begin{lstlisting}[language=JavaScript]
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"></script>
<script type="text/babel">
// Your ES6 code
</script>
\end{lstlisting}


注意，网页中实时将ES6代码转为ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。

下面是如何将代码打包成浏览器可以使用的脚本，以Babel配合Browserify为例。首先，安装babelify模块。

\begin{lstlisting}[language=JavaScript]
$ npm install --save-dev babelify babel-preset-es2015
\end{lstlisting}

然后，再用命令行转换ES6脚本。

\begin{lstlisting}[language=JavaScript]
$  browserify script.js -o bundle.js \
  -t [ babelify --presets [ es2015 ] ]
\end{lstlisting}

上面代码将ES6脚本script.js，转为bundle.js，浏览器直接加载后者就可以了。

在package.json设置下面的代码，就不用每次命令行都输入参数了。


\begin{lstlisting}[language=JavaScript]
{
  "browserify": {
    "transform": [["babelify", { "presets": ["es2015"] }]]
  }
}
\end{lstlisting}

Babel提供一个REPL在线编译器(\url{https://babeljs.io/repl/})，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。

\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\subsection{.babelrc}



Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。


该文件用来设置转码规则和插件，基本格式如下。



\begin{lstlisting}[language=JavaScript]
{
  "presets": [],
  "plugins": []
}
\end{lstlisting}

presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。


\begin{lstlisting}[language=JavaScript]
# ES2015转码规则
$ npm install --save-dev babel-preset-es2015

# react转码规则
$ npm install --save-dev babel-preset-react

# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个
$ npm install --save-dev babel-preset-stage-0
$ npm install --save-dev babel-preset-stage-1
$ npm install --save-dev babel-preset-stage-2
$ npm install --save-dev babel-preset-stage-3
\end{lstlisting}

然后，将这些规则加入.babelrc。



\begin{lstlisting}[language=JavaScript]
{
    "presets": [
      "es2015",
      "react",
      "stage-2"
    ],
    "plugins": []
}
\end{lstlisting}


注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。

\begin{compactitem}
\item babel-cli
\item babel-node
\item babel-register
\item babel-core
\item babel-polyfill
\end{compactitem}


\subsection{babel-cli}

Babel提供babel-cli工具，用于命令行转码。

\begin{lstlisting}[language=JavaScript]
$ npm install --global babel-cli
# 转码结果输出到标准输出
$ babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ babel example.js --out-file compiled.js
# 或者
$ babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ babel src --out-dir lib
# 或者
$ babel src -d lib

# -s 参数生成source map文件
$ babel src -d lib -s
\end{lstlisting}

上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的Babel。

一个解决办法是将babel-cli安装在项目之中。


\begin{lstlisting}[language=JavaScript]
$ npm install --save-dev babel-cli
\end{lstlisting}


然后，改写package.json。


\begin{lstlisting}[language=JavaScript]
{
  // ...
  "devDependencies": {
    "babel-cli": "^6.0.0"
  },
  "scripts": {
    "build": "babel src -d lib"
  },
}
\end{lstlisting}

转码的时候，就执行下面的命令。





\begin{lstlisting}[language=JavaScript]
$ npm run build
\end{lstlisting}


\subsection{babel-node}



babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。

它不用单独安装，而是随babel-cli一起安装。然后，执行babel-node就进入REPL环境。




\begin{lstlisting}[language=JavaScript]
$ babel-node
> (x => x * 2)(1)
2
\end{lstlisting}

babel-node命令可以直接运行ES6脚本。将上面的代码放入脚本文件es6.js，然后直接运行。


\begin{lstlisting}[language=JavaScript]
$ babel-node es6.js
2
\end{lstlisting}



babel-node也可以安装在项目中。

\begin{lstlisting}[language=JavaScript]
$ npm install --save-dev babel-cli
\end{lstlisting}


然后，改写package.json。



\begin{lstlisting}[language=JavaScript]
{
  "scripts": {
    "script-name": "babel-node script.js"
  }
}
\end{lstlisting}

上面代码中，使用babel-node替代node，这样script.js本身就不用做任何转码处理。

\subsection{babel-register}

babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。



\begin{lstlisting}[language=JavaScript]
$ npm install --save-dev babel-register
\end{lstlisting}



使用时，必须首先加载babel-register。

\begin{lstlisting}[language=JavaScript]
require("babel-register");
require("./index.js");
\end{lstlisting}


然后，就不需要手动对index.js转码了。

需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。



\subsection{babel-core}


如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。


\begin{lstlisting}[language=JavaScript]
$ npm install babel-core --save
\end{lstlisting}


然后，在项目中就可以调用babel-core。


\begin{lstlisting}[language=JavaScript]
var babel = require('babel-core');

// 字符串转码
babel.transform('code();', options);
// => { code, map, ast }

// 文件转码（异步）
babel.transformFile('filename.js', options, function(err, result) {
  result; // => { code, map, ast }
});

// 文件转码（同步）
babel.transformFileSync('filename.js', options);
// => { code, map, ast }

// Babel AST转码
babel.transformFromAst(ast, code, options);
// => { code, map, ast }
\end{lstlisting}


下面是一个例子。

\begin{lstlisting}[language=JavaScript]
var es6Code = 'let x = n => n + 1';
var es5Code = require('babel-core')
  .transform(es6Code, {
    presets: ['es2015']
  })
  .code;
// '"use strict";\n\nvar x = function x(n) {\n  return n + 1;\n};'
\end{lstlisting}


上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的ES6代码，第二个参数是转换的配置对象。

\subsection{babel-polyfill}

Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。

举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。

\begin{lstlisting}[language=JavaScript]
$ npm install --save babel-polyfill
\end{lstlisting}



然后，在脚本头部，加入如下一行代码。




\begin{lstlisting}[language=JavaScript]
import 'babel-polyfill';
// 或者
require('babel-polyfill');
\end{lstlisting}


Babel默认不转码的API非常多。


\section{ESLint}


许多工具需要Babel进行前置转码，这里举两个例子：ESLint和Mocha。

ESLint用于静态检查代码的语法和风格，安装命令如下。

\begin{lstlisting}[language=JavaScript]
$ npm install --save-dev eslint babel-eslint
\end{lstlisting}


然后，在项目根目录下，新建一个配置文件.eslintrc，在其中加入parser字段。






\begin{lstlisting}[language=JavaScript]
{
  "parser": "babel-eslint",
  "rules": {
    ...
  }
}
\end{lstlisting}

再在package.json之中，加入相应的scripts脚本。



\begin{lstlisting}[language=JavaScript]
{
    "name": "my-module",
    "scripts": {
      "lint": "eslint my-files.js"
    },
    "devDependencies": {
      "babel-eslint": "...",
      "eslint": "..."
    }
}
\end{lstlisting}

\section{Mocha}

Mocha则是一个测试框架，如果需要执行使用ES6语法的测试脚本，可以修改package.json的scripts.test。



\begin{lstlisting}[language=JavaScript]
"scripts": {
  "test": "mocha --ui qunit --compilers js:babel-core/register"
}
\end{lstlisting}


上面命令中，\texttt{-\/-compilers}参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。


\section{Traceur}

Google公司的Traceur转码器，也可以将ES6代码转为ES5代码。

Traceur允许将ES6代码直接插入网页。首先，必须在网页头部加载Traceur库文件。

\begin{lstlisting}[language=JavaScript]
<script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script>
<script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script>
<script src="https://google.github.io/traceur-compiler/src/bootstrap.js"></script>
<script type="module">
  import './Greeter.js';
</script>
\end{lstlisting}

上面代码中，一共有4个script标签。第一个是加载Traceur的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用ES6代码。

注意，第四个script标签的type属性的值是module，而不是text/javascript。这是Traceur编译器识别ES6代码的标志，编译器会自动将所有type=module的代码编译为ES5，然后再交给浏览器执行。

除了引用外部ES6脚本，也可以直接在网页中放置ES6代码。

\begin{lstlisting}[language=JavaScript]
<script type="module">
  class Calc {
    constructor(){
      console.log('Calc constructor');
    }
    add(a, b){
      return a + b;
    }
  }

  var c = new Calc();
  console.log(c.add(4,5));
</script>
\end{lstlisting}

正常情况下，上面代码会在控制台打印出9。

如果想对Traceur的行为有精确控制，可以采用下面参数配置的写法。

\begin{lstlisting}[language=JavaScript]
<script>
  // Create the System object
  window.System = new traceur.runtime.BrowserTraceurLoader();
  // Set some experimental options
  var metadata = {
    traceurOptions: {
      experimental: true,
      properTailCalls: true,
      symbols: true,
      arrayComprehension: true,
      asyncFunctions: true,
      asyncGenerators: exponentiation,
      forOn: true,
      generatorComprehension: true
    }
  };
  // Load your module
  System.import('./myModule.js', {metadata: metadata}).catch(function(ex) {
    console.error('Import failed', ex.stack || ex);
  });
</script>
\end{lstlisting}


上面代码中，首先生成Traceur的全局对象window.System，然后System.import方法可以用来加载ES6模块。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持ES6功能。如果设为\texttt{experimental: true}，就表示除了ES6以外，还支持一些实验性的新功能。


Traceur也提供一个在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。

上面的例子转为ES5代码运行，就是下面这个样子。


\begin{lstlisting}[language=JavaScript]
<script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script>
<script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script>
<script src="https://google.github.io/traceur-compiler/src/bootstrap.js"></script>
<script>
$traceurRuntime.ModuleStore.getAnonymousModule(function() {
  "use strict";

  var Calc = function Calc() {
    console.log('Calc constructor');
  };

  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {
    return a + b;
  }}, {});

  var c = new Calc();
  console.log(c.add(4, 5));
  return {};
});
</script>
\end{lstlisting}

作为命令行工具使用时，Traceur是一个Node的模块，首先需要用Npm安装。



\begin{lstlisting}[language=JavaScript]
$ npm install -g traceur
\end{lstlisting}

安装成功后，就可以在命令行下使用Traceur了。

Traceur直接运行es6脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。


\begin{lstlisting}[language=JavaScript]
$ traceur calc.js
Calc constructor
9
\end{lstlisting}


如果要将ES6脚本转为ES5保存，要采用下面的写法。


\begin{lstlisting}[language=JavaScript]
$ traceur --script calc.es6.js --out calc.es5.js
\end{lstlisting}

上面代码的--script选项表示指定输入文件，--out选项表示指定输出文件。

为了防止有些特性编译不成功，最好加上--experimental选项。


\begin{lstlisting}[language=JavaScript]
$ traceur --script calc.es6.js --out calc.es5.js --experimental
\end{lstlisting}

命令行下转换生成的文件，就可以直接放到浏览器中运行。


Traceur的Node.js用法如下（假定已安装traceur模块）。


\begin{lstlisting}[language=JavaScript]
var traceur = require('traceur');
var fs = require('fs');

// 将ES6脚本转为字符串
var contents = fs.readFileSync('es6-file.js').toString();

var result = traceur.compile(contents, {
  filename: 'es6-file.js',
  sourceMap: true,
  // 其他设置
  modules: 'commonjs'
});

if (result.error)
  throw result.error;

// result对象的js属性就是转换后的ES5代码
fs.writeFileSync('out.js', result.js);
// sourceMap属性对应map文件
fs.writeFileSync('out.js.map', result.sourceMap);
\end{lstlisting}



\chapter{Variable}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\chapter{Datatype}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\chapter{Number}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\chapter{String}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\chapter{Function}


\section{Curry}


函数柯里化（curry）过程通过逐步传参，在每一步中返回一个更具体的部分配置的函数。

函数柯里化不断传参的过程可以实现对函数的高度服用，而且函数柯里化利用闭包、高阶函数特性来实现动态创建函数和函数复用，最终使得代码逻辑更加清晰，代码实现更加优雅。






通常情况下使用以下方式来注册DOM事件：

\begin{lstlisting}[language=JavaScript]
var addEvent = function(el, type, fn, capture) {
   if(window.addEventLister) {
     el.addEventListener(type, function(e) {
        fn.call(el,e);
     },capture);
   } else if (window.attachEvent) {
     el.attachEvent("" + type, function(e) {
       fn.call(el,e);
     });
   }
}
\end{lstlisting}


使用上述方式的问题是每次调用addEvent方法时，都会执行一次判断来决定使用哪个方法来注册事件。

实际上，可以在页面载入后只进行一次判断，然后就可以使用同一注册方法来注册不同的事件。

下面的示例使用函数柯里化来实现动态创建函数。

\begin{lstlisting}[language=JavaScript]
var addEvent = (function(){
  if(window.addEventListener) {
    return function(el,sType,fn,capture){
      el.addEventListener(sType,function(e){
        fn.call(el,e);
      },(capture));
    };
  } else if (window.attachEvent){
    return function(el,sType,fn,capture){
      el.attachEvent("" + type, function(e){
        fn.call(el,e);
      });
    };
  }
})()
\end{lstlisting}

使用函数柯里化实现的自执行代码首先会判断浏览器支持的事件注册方法，根据不同的注册方法返回一个事件注册的函数赋值给addEvent，以后调用addEvent方法注册事件时，内部就不需要再次进行判断，直接使用当前浏览器支持的事件注册方法来注册相应的事件。

如果需要求出10和任意数的和，可以使用下面的写法：

\begin{lstlisting}[language=JavaScript]
function sum(x,y) {
   return x+y;
}

sum(10,20); // 30
sum(10,55); // 65
\end{lstlisting}

这里，多次调用同一方法时会传入一个相同的参数10，如果使用函数柯里化就可以实现参数复用，例如：





\begin{lstlisting}[language=JavaScript]
function sum(x) {
  return function(y) {
    return x+y;
  }
}

var addTen = sum(10);
addTen(20); // 30
addTen(55); // 65
\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\chapter{Array}


\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}








\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}








\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}









\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}









\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}








\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}

\chapter{Object}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}









\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\chapter{Generator}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\chapter{Promise}


\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\chapter{Class}


\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}










\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}







\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


