\part{Vue Component}


\chapter{Overview}



\chapter{Build-in Component}




\section{component}

<component>元素可以渲染一个“元组件”为动态组件，并且根据 is 的值来决定哪个组件被渲染。

\begin{lstlisting}[language=JavaScript]
<!-- 动态组件由 vm 实例的属性值 `componentId` 控制 -->
<component :is="componentId"></component>
<!-- 也能够渲染注册过的组件或 prop 传入的组件 -->
<component :is="$options.components.child"></component>
\end{lstlisting}

\subsection{Props}

\begin{compactitem}
\item is - \texttt{string|ComponentDefinition|ComponentConstructor}
\item inline-template - \texttt{boolean}
\end{compactitem}






\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}


\section{transition}


<transition> 元素作为单个元素/组件的过渡效果。<transition> 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。

\begin{lstlisting}[language=JavaScript]
<!-- 简单元素 -->
<transition>
  <div v-if="ok">toggled content</div>
</transition>
<!-- 动态组件 -->
<transition name="fade" mode="out-in" appear>
  <component :is="view"></component>
</transition>
<!-- 事件钩子 -->
<div id="transition-demo">
  <transition @after-enter="transitionComplete">
    <div v-show="ok">toggled content</div>
  </transition>
</div>

<script>
new Vue({
  ...
  methods: {
    transitionComplete: function (el) {
      // 传入 'el' 这个 DOM 元素作为参数。
    }
  }
  ...
}).$mount('#transition-demo')
</script>
\end{lstlisting}



\subsection{Props}

\begin{compactitem}
\item name - \texttt{string}, 用于自动生成 CSS 过渡类名。例如：name: 'fade' 将自动拓展为.fade-enter，.fade-enter-active等。默认类名为 "v"
\item appear - \texttt{boolean}, 是否在初始渲染时使用过渡。默认为 false。
\item css - \texttt{boolean}, 是否使用 CSS 过渡类。默认为 true。如果设置为 false，将只通过组件事件触发注册的 JavaScript 钩子。
\item type - \texttt{string}, 指定过渡事件类型，侦听过渡何时结束。有效值为 "transition" 和 "animation"。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。
\item mode - \texttt{string}, 控制离开/进入的过渡时间序列。有效的模式有 "out-in" 和 "in-out"；默认同时生效。
\item enter-class - \texttt{string}
\item leave-class - \texttt{string}
\item enter-active-class - \texttt{string}
\item leave-active-class - \texttt{string}
\item appear-class - \texttt{string}
\item appear-active-class - \texttt{string}
\end{compactitem}


\subsection{Events}


\begin{compactitem}
\item before-enter
\item enter
\item after-enter
\item before-leave
\item leave
\item after-leave
\item before-appear
\item appear
\item after-appear
\end{compactitem}








\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\section{transition-group}



<transition-group> 元素作为多个元素/组件的过渡效果。<transition-group> 渲染一个真实的 DOM 元素。默认渲染 <span>，可以通过 tag 属性配置哪个元素应该被渲染。

注意，每个 <transition-group> 的子节点必须有 独立的key ，动画才能正常工作


<transition-group> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类（通过 name 属性或配置 move-class 属性自动生成）。如果 CSS transform 属性是“可过渡”属性，当应用移动类时，将会使用 FLIP 技术 使元素流畅地到达动画终点。

\begin{lstlisting}[language=JavaScript]
<transition-group tag="ul" name="slide">
  <li v-for="item in items" :key="item.id">
    {{ item.text }}
  </li>
</transition-group>
\end{lstlisting}


\subsection{Props}


\begin{compactitem}
\item tag - \texttt{string}，默认为\texttt{span}
\item move-class - 覆盖移动过渡期间应用的CSS类
\item 除了mode，其他属性和<transition>相同
\end{compactitem}


\subsection{Events}

事件和<transition>相同。


\begin{compactitem}
\item before-enter
\item enter
\item after-enter
\item before-leave
\item leave
\item after-leave
\item before-appear
\item appear
\item after-appear
\end{compactitem}


\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\section{keep-alive}


<keep-alive>主要用于保留组件状态或避免重新渲染，具体来说就是<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。


和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。


当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。

\begin{lstlisting}[language=JavaScript]
<!-- 基本 -->
<keep-alive>
  <component :is="view"></component>
</keep-alive>
<!-- 多个条件判断的子组件 -->
<keep-alive>
  <comp-a v-if="a > 1"></comp-a>
  <comp-b v-else></comp-b>
</keep-alive>
<!-- 和 <transition> 一起使用 -->
<transition>
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>
</transition>
\end{lstlisting}


\subsection{Props}

\begin{compactitem}
\item include - string or RegExp. Only components matched by this will be cached.
\item exclude - string or RegExp. Any component matched by this will not be cached.
\end{compactitem}

The include and exclude props allow components to be conditionally cached. Both props can either be a comma-delimited string or a RegExp:



\begin{lstlisting}[language=JavaScript]
<!-- comma-delimited string -->
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>
<!-- regex (use v-bind) -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>
\end{lstlisting}


The match is first checked on the component’s own name option, then its local registration name (the key in the parent’s components option) if the name option is not available. Anonymous components cannot be matched against.


<keep-alive> 不会在函数式组件中正常工作，因为它们没有缓存实例。


\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\section{slot}




<slot> 元素作为组件模板之中的内容分发插槽。 <slot> 元素自身将被替换。



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}

\subsection{Props}


\begin{compactitem}
\item name - string，用于命名插槽
\end{compactitem}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}






