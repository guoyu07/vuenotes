\part{JavaScript}

\chapter{Overview}


JavaScript和JScript等都是ECMA-262（ECMAScript）标准的实现和扩展，虽然二者出于不同的目的，但是现在JavaScript和JScript都可以与ECMAScript相容，但是包含超出ECMAScript的功能。



\section{Node.js}

Node.js是JavaScript语言的服务器运行环境，对ES6的支持度比浏览器更高。通过Node，可以体验更多ES6的特性。建议使用版本管理工具nvm来安装Node，因为可以自由切换版本。



在Node.js出现之前，JavaScript主要用来向HTML页面添加交互行为，可以直接嵌入HTML页面，不过单独的js文件有利于结构和行为的分离。

\begin{lstlisting}[language=JavaScript]
<!DOCTYPE html>
<html>
    <head>
    <title>Hello World</title>
        <script type="text/javascript">
        // 在浏览器视窗内直接显示
        document.write("Hello, world!"); 
        // 弹窗显示
        alert("Hello, world!"); 
        // 在控制台（console）里显示
        console.log("Hello, world!");
        </script>
    </head>
    <body>
    <!-- HTML 内容 -->
    </body>
</html>
\end{lstlisting}

在浏览器的地址栏中可以使用\texttt{javascript:}以交互方式运行JavaScript：

\begin{lstlisting}[language=JavaScript]
javascript:alert("Hello world!");
\end{lstlisting}

\begin{compactitem}
\item JavaScript中的表达式和语句是不同的；
\item JavaScript支持自动在语句末尾添加分号。
\end{compactitem}


JavaScript的语法可以操控文本、数组、日期以及正则表达式等，但是不支持I/O（例如网络、存储和图形等），不过这些都可以通过其宿主环境提供支持。

V8引擎、Node.js框架、事件驱动和异步I/O的特性使得JavaScript可以被用来编写服务器端程序，而且Node.js的出现更使得JavaScript可以运行在游戏、桌面和移动应用程序和开发和服务器环境中，不过最通用的JavaScript宿主环境仍然是Web浏览器。

Web浏览器使用公共的API创建“宿主对象”以便于在JavaScript中支持DOM。

\begin{compactitem}
\item 嵌入动态文本于HTML页面
\item 对浏览器事件作出响应
\item 读写HTML元素
\item 在数据被提交到服务器之前验证数据
\item 检测访客的浏览器信息
\item 控制cookies，包括创建和修改等
\end{compactitem}





JavaScript通过ECMAScript实现标准化，已经支持面向对象编程、命令式编程和函数式编程。

许多应用程序（特别是Web浏览器）都支持ECMAScript，而且浏览器中的ECMAScript实现（例如V8）添加了与DOM（文档对象模型）交互的接口，可以通过ECMAScript脚本改变网页的内容、结构和样式。

\begin{compactitem}
\item Firefox Gecko、SpiderMonkey和Rhino
\item Chrome V8
\item IE Trident
\item Opera
\item Konqeror KHTML
\item  Safari KHTML
\end{compactitem}



注意，和主流的JavaScript引擎都是每次运行时加载JavaScript代码并解析不同，V8是将所有JavaScript代码解析后才开始运行，其他引擎则是逐行解析（SpiderMonkey会将解析过的指令暂存来提高性能）。

实际上，完整的JavaScript实现应该包含三个部分，分别是：

\begin{compactenum}
\item ECMAScript（语言核心）描述了该语言的语法和基本对象；
\item DOM（文档对象模型）描述处理网页内容的方法和接口；
\item BOM（浏览器对象模型）描述与浏览器进行交互的方法和接口。
\end{compactenum}

一个典型的Web浏览器有一个图形引擎和一个独立的JavaScript引擎。例如，V8与WebKit被内置于Google Chrome中，这样JavaScript引擎能够被更方便的测试、重新生成或者在其他项目中使用。

JavaScript引擎（例如V8）实际上就是一个专门处理JavaScript脚本的虚拟机，一般会内置在Web浏览器中来提供操作浏览器的功能（例如网络、DOM、外部事件、HTML5视频、Canvas和存储）。





JavaScript基于原型（Prototype）来支持面向对象，并且支持函数优先。

\begin{compactitem}
\item eval() 函数可以直接运行一个JavaScript函数。

\begin{lstlisting}[language=JavaScript]
eval("alert(\"Message\")");
\end{lstlisting}

\end{compactitem}


\section{Scope}






JavaScript支持和C语言相似的结构化编程语法（例如if条件语句、while循环、switch语句、do-while循环等），但是作用域是一个例外——JavaScript只支持使用var关键字来定义变量的函数作用域。




ECMAScript加入了let关键字来支持块级作用域，这样就意味着JavaScript可以既支持函数作用域又支持块级作用域。

\begin{compactitem}
\item var声明的变量在全局作用域中都有效；
\item let声明的变量只在let命令所在的代码块内有效。
\end{compactitem}

var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。不过，按照一般的逻辑，变量应该在声明语句之后才可以使用，因此let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。



\section{Typing}


和大部分动态类型的脚本语言类似，JavaScript的类型与值而不是与变量关联。例如，x变量可以为数值，随后又可被赋值为字符串，JavaScript提供了包括鸭子类型（duck typing）在内的方法来检测变量类型。

鸭子类型是动态类型的一种风格，一个JavaScript对象有效的语义不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。

\begin{lstlisting}[language=JavaScript]
function Duck() {
  // Dynamically add functions to this object
  this.quack = function() { alert('Quaaaaaack!'); };
  this.feathers = function() { alert('The duck has white and gray feathers.'); };
}

function Person() {
  // Dynamically add functions to this object
  this.quack = function() { alert('The person imitates a duck.'); };
  this.feathers = function() { alert('The person takes a feather from the ground and shows it.'); };
  this.name = function() { alert('John Smith'); };
}

function inTheForest(object) {
  if (object.quack)     // Check that the .quack() function exists
    object.quack();
  if (object.feathers)  // Check that the .feathers() function exists
    object.feathers();
}

function game() {
  var donald = new Duck();
  var john = new Person();
  inTheForest(donald);
  inTheForest(john);
}

// Execute upon page load
game();
\end{lstlisting}

JavaScript支持更明确的测试，包括检查成员的运行时类型：


\begin{lstlisting}[language=JavaScript]
function inTheForest(object) {
  if (object.quack  &&  typeof(object.quack) == 'function')        // Check that the .quack() function exists
    object.quack();
  if (object.feathers  &&  typeof(object.feathers) == 'function')  // Check that the .feathers() function exists
    object.feathers();
}
\end{lstlisting}

在JavaScript中，如果一条语句运行不了，那么其后面的语言也无法运行，解决办法就是于使用try\{\}catch()\{\}︰

\begin{lstlisting}[language=JavaScript]
console.log("a");    //正确
console.log("b");    //正确
console.logg("c");   //这是错误的，并且到这里会停下来
console.log("d");    //正确
console.log("e");    //正确

/*解决方案*/
try{console.log("a");}catch(e){}    //正确
try{console.log("b");}catch(e){}    //正确
try{console.logg("c");}catch(e){}   //这是错误的，但是到这里不会停下来，而是跳过
try{console.log("d");}catch(e){}    //正确
try{console.log("e");}catch(e){}    //正确
\end{lstlisting}



\chapter{React}


React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案，也就是说只用 React 没法写大型应用。为了解决这个问题，2014年 Facebook 提出了 Flux 架构的概念。




\chapter{Redux}


2015年出现的Redux将Flux与函数式编程结合一起成为了最热门的前端架构。


